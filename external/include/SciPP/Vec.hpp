#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file Vec.hpp
/// \brief Functions and classes for vectors manipulations.
/// \author Reiex
/// 
/// For a more detailed description, see class Vec.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <SciPP/types.hpp>
#include <SciPP/Tensor.hpp>

namespace scp
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \class Vec
	/// \brief Class for vectors manipulations
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	class Vec : public Tensor<T, 1>
	{
		public:

			Vec() = delete;
			Vec(const Tensor<T, 1>& tensor);		///< Init the vector from a tensor of order 1.
			Vec(Tensor<T, 1>&& tensor);				///< Init the vector from a tensor of order 1.
			Vec(uint64_t count, int64_t value = 0);	///< Init all the components of the vector with T(value).
			Vec(uint64_t count, const T& value);	///< Init all the components of the vector with value.
			Vec(const std::vector<T>& values);		///< Init the vector directly with values.
			Vec(const Vec<T>& v) = default;
			Vec(Vec<T>&& v) = default;

			Vec<T>& operator=(const Vec<T>& a);
			Vec<T>& operator=(Vec<T>&& a);

			~Vec() = default;
	};

	// Display

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Output stream operator for class Vec
	/// 
	/// Writes the vector under the format `x0 x1 ... xn` with `xi` and `...` the elements of the vector.
	///
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	std::ostream& operator<<(std::ostream& stream, const Vec<T>& v);

	// Specific functions

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Cross product between two 3-dimensional vectors
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<T> crossProduct(const Vec<T>& u, const Vec<T>& v);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Discrete Fourier Transform of a vector.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<std::complex<T>> dft(const Vec<std::complex<T>>& f);
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Inverse Discrete Fourier Transform of a vector.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<std::complex<T>> idft(const Vec<std::complex<T>>& fh);
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Fast Fourier Transform of a vector - computed using Cooley-Tukey algorithm.
	/// 
	/// Can only compute discrete Fourier transform for vectors of size a power of 2. It belongs to the user to verify
	/// this condition.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<std::complex<T>> fft(const Vec<std::complex<T>>& f);
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Inverse Fast Fourier Transform of a vector - computed using Cooley-Tukey algorithm.
	/// 
	/// Can only compute inverse discrete Fourier transform for vectors of size a power of 2. It belongs to the user to
	/// verify this condition.
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<std::complex<T>> ifft(const Vec<std::complex<T>>& f);

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Discrete Cosine Transform of a vector. (Type II corrected)
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<T> dct(const Vec<T>& f);
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \relates Vec
	/// \brief Inverse Discrete Cosine Transform of a vector. (Type II corrected)
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	template<typename T>
	Vec<T> idct(const Vec<T>& fh);
}

#include <SciPP/VecT.hpp>
