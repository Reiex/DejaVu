#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/// \file
/// \brief Functions and classes for feature detection.
/// \author Reiex
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include <DejaVu/types.hpp>

namespace djv
{
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	/// \addtogroup ImageProcessing
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	namespace edgeDetectors
	{
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \addtogroup edgeDetectors
		/// \ingroup ImageProcessing
		/// \{
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns the result of the Marr-Hildreth edge detection algorithm.
		/// 
		/// The Marr-Hildreth edge detection algorithm is a simple evaluation of whether the laplacian changes sign or
		/// not at proximity of a pixel. If the sign changes, then the pixel is part of an edge, and its strength is
		/// the square of the magnitude of the gradient at that pixel.
		/// 
		/// The gradient computation method used is djv::operators::simpleGradient.
		/// The laplacian computation method used is djv::operators::simpleLaplacian.
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		scp::Mat<float> marrHildreth(const scp::Mat<float>& m);
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns the result of the Canny edge detection algorithm.
		/// 
		/// The Canny edge detection algorithm is a simple evaluation of whether the magnitude of the gradient is at a
		/// local maximum or not at a pixel. If it is, then the pixel is part of an edge, and its strength is the
		/// square of the magnitude of the gradient at that pixel.
		/// 
		/// The gradient computation method used is djv::operators::simpleGradient.
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		scp::Mat<float> canny(const scp::Mat<float>& m, float sigma = 1.5f);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}

	namespace lineExtractors
	{
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \addtogroup lineExtractors
		/// \ingroup ImageProcessing
		/// \{
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \brief Returns a list of lines detected using Hough transform.
		/// 
		/// The Hough transform is first computed using a discretization of the Hough space using dTheta and dRho.
		/// Then the matrix containing the Hough transform is normalized.
		/// Finaly, a line is computed for every coefficient of the matrix greater than `threshold`.
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		std::vector<Line> hough(const scp::Mat<float>& m, float threshold = 0.5f, float dTheta = 0.1f, float dRho = 5.f);

		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/// \}
		///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	}

}
